@@grammar::Gherkin
@@whitespace :: /[\t ]+/
@@parseinfo :: True
@@eol_comments :: /#(.*)(\n|$)/

start = gherkin_document $;

gherkin_document = [_NL] @:feature [_NL];

simpledesc = {/.+/ _NL}+ ;
feature = [tags:tag_lines] feature_line:feature_line [description:DESCRIPTION] [background:background] [scenarios:scenarios] ;
feature_line = FEATURE ":" ~ feature_name:string _NL ;


# Using uppercase rule name will avoiding ignoring the whitespaces at the beginning
DESCRIPTION = lines:{DESCRIPTION_LINE} ;
DESCRIPTION_LINE = !(BACKGROUND | SCENARIO | SCENARIO_OUTLINE | tag) body:/.+/ nl:_NL;
#description = lines:{ !bg_scenarios /.+/ _NL } &bg_scenarios ;
#description = { !bg_scenarios /(?s)./ _NL } &bg_scenarios ;  # working
#description = { !bg_scenarios ?'.' } &bg_scenarios ;  # working
#description = { !bg_scenarios /./ } &bg_scenarios ;  # working
#description = ->&bg_scenarios ;

tag = /@\S+/ ;
# tag_line = {tag:tag}+ _NL ;
# tag_lines = {tag_line}+ ;

tag_lines = {tag:tag /\s+/}+ ;

background = keyword:BACKGROUND ":" ~ [name:string] _NL [steps:given_steps] ;

scenarios = @:{scenario}+ ;

scenario =
    [tags:tag_lines] (
        | SCENARIO ":" ~ scenario_name:string _NL [steps:steps_section]
        | SCENARIO_OUTLINE_ALTS ":" ~ scenario_name:string _NL [steps:steps_section] [examples:examples]
    )
    ;


step_def =
    # The hack actually prevents us from parsing step docstring and table :(
    # | name:string _NL  # Hack to have an error message displaying "Expecting Given" in case we only want given steps
    name:string _NL [docstring:step_docstring] [table:table]
    ;

steps_section =
    | plain_steps:given_steps nested_steps:{when_steps | then_steps}
    | [plain_steps:given_steps] nested_steps:{when_steps | then_steps}+
    ;

# TODO: Try out this:
# step(keyword=GIVEN) = GIVEN step_def:step_def ;

given_step = keyword:step_keyword_given ~ step_def:step_def ;
when_step = keyword:step_keyword_when ~ step_def:step_def ;
then_step = keyword:step_keyword_then ~ step_def:step_def ;
and_step = keyword:step_keyword_and ~ step_def:step_def ;
but_step = keyword:step_keyword_but ~ step_def:step_def ;

step_keyword_given = keyword:GIVEN ;
step_keyword_when = keyword:WHEN ;
step_keyword_then = keyword:THEN ;
step_keyword_and = keyword:AND ;
step_keyword_but = keyword:BUT ;

given_steps = {steps+:given_step}+ {steps+:and_step | steps+:but_step} ;
when_steps = {steps+:when_step}+ {steps+:and_step | steps+:but_step} ;
then_steps = {steps+:then_step}+ {steps+:and_step | steps+:but_step} ;

examples = EXAMPLES_ALTS ":" ~ [name:string] _NL table:table ;

table = rows:{table_row}+ ;
# The idea here is to match the initial "|" and the each cell is a .* match but it cannot end with a "\" (it would
# escape the following "|")
table_row = cells:/(?x)
(
  \|                  # Initial pipe
  .*                  # Anything...
  (?<!\\)(?:\\\\)*?   # ...that ends with an even number of backslashes (r'', r'\\', r'\\\\', ...)...
  \|                  # ...before the ending pipe
)
/ _NL ;

# This trick allows us to get the right initial indentation
step_docstring = @:step_docstring_inner ;

step_docstring_inner = container:/(?sx)
("""|'''|```)(.*?)    # The triple quotes, followed optionally by the content type
\n                    # new line
(.*)                  # Anything
\n[t ]*               # We require a new line (and whitespaces)...
\1                    # ...before matching the initial triple quote
/ _NL ;


string = /.+/ ;

EXAMPLES = "Examples" ;
SCENARIOS = "Scenarios" ;
BACKGROUND = "Background" ;
SCENARIO = "Scenario" ;
SCENARIO_OUTLINE = "Scenario Outline" ;
SCENARIO_TEMPLATE = "Scenario Template" ;
FEATURE = "Feature" ;
GIVEN = "Given" ;
WHEN = "When" ;
THEN = "Then" ;
AND = "And" ;
BUT = "But" ;

EXAMPLES_ALTS = EXAMPLES | SCENARIOS ;
SCENARIO_OUTLINE_ALTS = SCENARIO_OUTLINE | SCENARIO_TEMPLATE ;

# _NL = /(\r?\n[\t ]*)+/ | $ ;
_NL = /(\r?\n)+/ | $ ;
